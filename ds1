// ==================================================================
// FILE: ds/1_InfixToPostfix.c
// ==================================================================

#include <stdio.h>
#include <ctype.h>

#define MAX 100

// Stack for operators
char stack[MAX];
int top = -1;

// Check if stack is empty
int isEmpty() {
    return top == -1;
}

// Push element into stack
void push(char c) {
    stack[++top] = c;
}

// Pop element from stack
char pop() {
    return stack[top--];
}

// Return top element
char peek() {
    return stack[top];
}

// Operator precedence
int precedence(char c) {
    if (c == '+' || c == '-') return 1;
    if (c == '*' || c == '/') return 2;
    if (c == '^') return 3;
    return 0;
}

// Convert infix → postfix
void infixToPostfix(char infix[]) {
    char postfix[MAX];
    int k = 0;

    for (int i = 0; infix[i] != '\0'; i++) {
        char c = infix[i];

        if (isalnum(c)) {
            postfix[k++] = c; // operand → output
        }
        else if (c == '(') {
            push(c);
        }
        else if (c == ')') {
            while (!isEmpty() && peek() != '(')
                postfix[k++] = pop();
            pop();                  // remove '('
        }
        else { // operator
            while (!isEmpty() && precedence(peek()) >= precedence(c))
                postfix[k++] = pop();
            push(c);
        }
    }

    while (!isEmpty())
        postfix[k++] = pop();

    postfix[k] = '\0';
    printf("Postfix Expression: %s\n", postfix);
}

int main() {
    char infix[MAX];

    printf("Enter Infix Expression: ");
    scanf("%s", infix);

    infixToPostfix(infix);
    return 0;
}


// ==================================================================
// FILE: ds/2_InfixToPrefix.c
// ==================================================================

#include <stdio.h>
#include <string.h>
#include <ctype.h>

#define MAX 100

char stack[MAX];
int top = -1;

int isEmpty() { return top == -1; }
void push(char c) { stack[++top] = c; }
char pop() { return stack[top--]; }
char peek() { return stack[top]; }

int precedence(char c) {
    if (c == '+' || c == '-') return 1;
    if (c == '*' || c == '/') return 2;
    if (c == '^') return 3;
    return 0;
}

// Reverse string and swap brackets
void reverse(char s[]) {
    int n = strlen(s);
    for (int i = 0; i < n/2; i++) {
        char temp = s[i];
        s[i] = s[n-i-1];
        s[n-i-1] = temp;
    }
    for (int i = 0; i < n; i++) {
        if (s[i] == '(') s[i] = ')';
        else if (s[i] == ')') s[i] = '(';
    }
}

// Convert infix → postfix (helper)
void infixToPostfix(char infix[], char postfix[]) {
    int k = 0;

    for (int i = 0; infix[i]; i++) {
        char c = infix[i];

        if (isalnum(c)) postfix[k++] = c;
        else if (c == '(') push(c);
        else if (c == ')') {
            while (!isEmpty() && peek() != '(')
                postfix[k++] = pop();
            pop();
        }
        else {
            while (!isEmpty() && precedence(peek()) >= precedence(c))
                postfix[k++] = pop();
            push(c);
        }
    }
    while (!isEmpty())
        postfix[k++] = pop();

    postfix[k] = '\0';
}

// Main prefix conversion
void infixToPrefix(char infix[]) {
    char postfix[MAX], prefix[MAX];

    reverse(infix); // Step 1
    infixToPostfix(infix, postfix); // Step 2
    strcpy(prefix, postfix);
    reverse(prefix); // Step 3

    printf("Prefix Expression: %s\n", prefix);
}

int main() {
    char infix[MAX];

    printf("Enter Infix Expression: ");
    scanf("%s", infix);

    infixToPrefix(infix);
    return 0;
}


// ==================================================================
// FILE: ds/3_MultipleStackInOneArray.c
// ==================================================================

#include <stdio.h>

#define MAX 50

// Two stacks in one array
int a[MAX];
int top1 = -1;
int top2 = MAX;

// Push in stack1
void push1(int x) {
    if (top1 + 1 == top2) {
        printf("Stack Overflow!\n");
        return;
    }
    a[++top1] = x;
    printf("Pushed in Stack1: %d\n", x);
}

// Push in stack2
void push2(int x) {
    if (top1 + 1 == top2) {
        printf("Stack Overflow!\n");
        return;
    }
    a[--top2] = x;
    printf("Pushed in Stack2: %d\n", x);
}

// Pop stack1
void pop1() {
    if (top1 == -1) {
        printf("Stack1 Underflow!\n");
        return;
    }
    printf("Popped from Stack1: %d\n", a[top1--]);
}

// Pop stack2
void pop2() {
    if (top2 == MAX) {
        printf("Stack2 Underflow!\n");
        return;
    }
    printf("Popped from Stack2: %d\n", a[top2++]);
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Push Stack1  2.Push Stack2  3.Pop Stack1  4.Pop Stack2  5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) { printf("Enter value: "); scanf("%d", &x); push1(x); }
        else if (ch == 2) { printf("Enter value: "); scanf("%d", &x); push2(x); }
        else if (ch == 3) pop1();
        else if (ch == 4) pop2();
        else break;
    }
}


// ==================================================================
// FILE: ds/4_KQueueInOneArray.c
// ==================================================================

#include <stdio.h>

#define MAX 50

// Two stacks in one array
int a[MAX];
int top1 = -1;
int top2 = MAX;

// Push in stack1
void push1(int x) {
    if (top1 + 1 == top2) {
        printf("Stack Overflow!\n");
        return;
    }
    a[++top1] = x;
    printf("Pushed in Stack1: %d\n", x);
}

// Push in stack2
void push2(int x) {
    if (top1 + 1 == top2) {
        printf("Stack Overflow!\n");
        return;
    }
    a[--top2] = x;
    printf("Pushed in Stack2: %d\n", x);
}

// Pop stack1
void pop1() {
    if (top1 == -1) {
        printf("Stack1 Underflow!\n");
        return;
    }
    printf("Popped from Stack1: %d\n", a[top1--]);
}

// Pop stack2
void pop2() {
    if (top2 == MAX) {
        printf("Stack2 Underflow!\n");
        return;
    }
    printf("Popped from Stack2: %d\n", a[top2++]);
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Push Stack1  2.Push Stack2  3.Pop Stack1  4.Pop Stack2  5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) { printf("Enter value: "); scanf("%d", &x); push1(x); }
        else if (ch == 2) { printf("Enter value: "); scanf("%d", &x); push2(x); }
        else if (ch == 3) pop1();
        else if (ch == 4) pop2();
        else break;
    }
}


// ==================================================================
// FILE: ds/5_PostfixEval.c
// ==================================================================

#include <stdio.h>
#include <ctype.h>

#define MAX 100

int stack[MAX];
int top = -1;

void push(int x) { stack[++top] = x; }
int pop() { return stack[top--]; }

// Evaluate postfix
int evaluate(char exp[]) {
    for (int i = 0; exp[i]; i++) {
        char c = exp[i];

        if (isdigit(c))
            push(c - '0');
        else {
            int b = pop();
            int a = pop();
            switch (c) {
                case '+': push(a + b); break;
                case '-': push(a - b); break;
                case '*': push(a * b); break;
                case '/': push(a / b); break;
            }
        }
    }
    return pop();
}

int main() {
    char exp[MAX];

    printf("Enter Postfix Expression: ");
    scanf("%s", exp);

    printf("Result: %d\n", evaluate(exp));
    return 0;
}


// ==================================================================
// FILE: ds/6_PrefixEval.c
// ==================================================================

#include <stdio.h>
#include <ctype.h>
#include <string.h>

#define MAX 100

int stack[MAX];
int top = -1;

void push(int x) { stack[++top] = x; }
int pop() { return stack[top--]; }

// Evaluate prefix
int evaluate(char exp[]) {
    int n = strlen(exp);
    for (int i = n - 1; i >= 0; i--) {
        char c = exp[i];

        if (isdigit(c))
            push(c - '0');
        else {
            int a = pop();
            int b = pop();
            switch (c) {
                case '+': push(a + b); break;
                case '-': push(a - b); break;
                case '*': push(a * b); break;
                case '/': push(a / b); break;
            }
        }
    }
    return pop();
}

int main() {
    char exp[MAX];

    printf("Enter Prefix Expression: ");
    scanf("%s", exp);

    printf("Result: %d\n", evaluate(exp));
    return 0;
}


// ==================================================================
// FILE: ds/7_QueuesUsingCircularArray.c
// ==================================================================

#include <stdio.h>

#define MAX 20

int queue[MAX];
int front = -1, rear = -1;

// Check if queue is empty
int isEmpty() {
    return front == -1;
}

// Check if queue is full
int isFull() {
    return (rear + 1) % MAX == front;
}

// Insert element
void enqueue(int x) {
    if (isFull()) {
        printf("Queue is Full!\n");
        return;
    }
    if (isEmpty()) {
        front = rear = 0;
    } else {
        rear = (rear + 1) % MAX;
    }
    queue[rear] = x;
    printf("Enqueued: %d\n", x);
}

// Delete element
void dequeue() {
    if (isEmpty()) {
        printf("Queue is Empty!\n");
        return;
    }
    printf("Dequeued: %d\n", queue[front]);

    if (front == rear)
        front = rear = -1;
    else
        front = (front + 1) % MAX;
}

// Get front element
void frontElement() {
    if (isEmpty()) printf("Queue Empty!\n");
    else printf("Front: %d\n", queue[front]);
}

// Get rear element
void rearElement() {
    if (isEmpty()) printf("Queue Empty!\n");
    else printf("Rear: %d\n", queue[rear]);
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Enqueue 2.Dequeue 3.isEmpty 4.isFull 5.Front 6.Rear 7.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            enqueue(x);
        }
        else if (ch == 2) dequeue();
        else if (ch == 3) printf("%s\n", isEmpty() ? "Empty" : "Not Empty");
        else if (ch == 4) printf("%s\n", isFull() ? "Full" : "Not Full");
        else if (ch == 5) frontElement();
        else if (ch == 6) rearElement();
        else break;
    }
    return 0;
}


// ==================================================================
// FILE: ds/8_IsLinkedListPalindrome.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *newNode = malloc(sizeof(struct Node));
    newNode->data = x;
    newNode->next = NULL;

    if (!head) return newNode;

    struct Node *temp = head;
    while (temp->next) temp = temp->next;
    temp->next = newNode;
    return head;
}

// Reverse linked list
struct Node* reverse(struct Node *head) {
    struct Node *prev = NULL, *curr = head, *next;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

// Check palindrome
int isPalindrome(struct Node *head) {
    if (!head || !head->next) return 1;

    struct Node *slow = head, *fast = head;

    // Find middle
    while (fast->next && fast->next->next) {
        slow = slow->next;
        fast = fast->next->next;
    }

    // Reverse second half
    struct Node *second = reverse(slow->next);

    // Compare halves
    struct Node *p1 = head, *p2 = second;
    while (p2) {
        if (p1->data != p2->data) return 0;
        p1 = p1->next;
        p2 = p2->next;
    }
    return 1;
}

int main() {
    struct Node *head = NULL;
    int x;

    printf("Enter elements (-1 to stop): ");
    while (1) {
        scanf("%d", &x);
        if (x == -1) break;
        head = insertEnd(head, x);
    }

    if (isPalindrome(head))
        printf("The list is a Palindrome.\n");
    else
        printf("The list is NOT a Palindrome.\n");

    return 0;
}


// ==================================================================
// FILE: ds/9_PolynomialAdditionLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int coeff, exp;
    struct Node *next;
};

// Insert term in decreasing exponent order
struct Node* insertTerm(struct Node *head, int c, int e) {
    struct Node *newNode = malloc(sizeof(struct Node));
    newNode->coeff = c;
    newNode->exp = e;
    newNode->next = NULL;

    if (!head || e > head->exp) {
        newNode->next = head;
        return newNode;
    }

    struct Node *temp = head;
    while (temp->next && temp->next->exp > e)
        temp = temp->next;

    newNode->next = temp->next;
    temp->next = newNode;

    return head;
}

// Add polynomials
struct Node* addPoly(struct Node *p1, struct Node *p2) {
    struct Node *res = NULL;

    while (p1 && p2) {
        if (p1->exp > p2->exp) {
            res = insertTerm(res, p1->coeff, p1->exp);
            p1 = p1->next;
        }
        else if (p2->exp > p1->exp) {
            res = insertTerm(res, p2->coeff, p2->exp);
            p2 = p2->next;
        }
        else {
            res = insertTerm(res, p1->coeff + p2->coeff, p1->exp);
            p1 = p1->next;
            p2 = p2->next;
        }
    }

    while (p1) { res = insertTerm(res, p1->coeff, p1->exp); p1 = p1->next; }
    while (p2) { res = insertTerm(res, p2->coeff, p2->exp); p2 = p2->next; }

    return res;
}

// Display polynomial
void display(struct Node *p) {
    while (p) {
        printf("%dx^%d ", p->coeff, p->exp);
        p = p->next;
    }
    printf("\n");
}

int main() {
    struct Node *p1 = NULL, *p2 = NULL;
    int c, e;

    printf("Enter Polynomial 1 (coeff exp), -1 to stop:\n");
    while (1) {
        scanf("%d", &c);
        if (c == -1) break;
        scanf("%d", &e);
        p1 = insertTerm(p1, c, e);
    }

    printf("Enter Polynomial 2 (coeff exp), -1 to stop:\n");
    while (1) {
        scanf("%d", &c);
        if (c == -1) break;
        scanf("%d", &e);
        p2 = insertTerm(p2, c, e);
    }

    struct Node *res = addPoly(p1, p2);

    printf("Resultant Polynomial: ");
    display(res);

    return 0;
}


// ==================================================================
// FILE: ds/10_PolynomialMultiplicationLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int coeff, exp;
    struct Node *next;
};

// Insert term in decreasing exponent order (combine like terms)
struct Node* insertTerm(struct Node *head, int c, int e) {
    if (c == 0) return head;

    struct Node *newNode = malloc(sizeof(struct Node));
    newNode->coeff = c;
    newNode->exp = e;
    newNode->next = NULL;

    if (!head || e > head->exp) {
        newNode->next = head;
        return newNode;
    }

    struct Node *temp = head, *prev = NULL;

    while (temp && temp->exp > e) {
        prev = temp;
        temp = temp->next;
    }

    if (temp && temp->exp == e) {
        temp->coeff += c;   // combine
        free(newNode);
        return head;
    }

    newNode->next = temp;
    prev->next = newNode;
    return head;
}

// Multiply two polynomials
struct Node* multiply(struct Node *p1, struct Node *p2) {
    struct Node *res = NULL;

    for (; p1; p1 = p1->next) {
        for (struct Node *q = p2; q; q = q->next) {
            int c = p1->coeff * q->coeff;
            int e = p1->exp + q->exp;
            res = insertTerm(res, c, e);
        }
    }
    return res;
}

// Display polynomial
void display(struct Node *p) {
    while (p) {
        printf("%dx^%d ", p->coeff, p->exp);
        p = p->next;
    }
    printf("\n");
}

int main() {
    struct Node *p1 = NULL, *p2 = NULL;
    int c, e;

    printf("Enter Polynomial 1 (coeff exp), -1 to stop:\n");
    while (1) {
        scanf("%d", &c);
        if (c == -1) break;
        scanf("%d", &e);
        p1 = insertTerm(p1, c, e);
    }

    printf("Enter Polynomial 2 (coeff exp), -1 to stop:\n");
    while (1) {
        scanf("%d", &c);
        if (c == -1) break;
        scanf("%d", &e);
        p2 = insertTerm(p2, c, e);
    }

    struct Node *res = multiply(p1, p2);

    printf("Resultant Polynomial: ");
    display(res);

    return 0;
}


// ==================================================================
// FILE: ds/11_DoublyLinkedListInsertAfter.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *prev, *next;
};

// Create new node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->prev = n->next = NULL;
    return n;
}

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = createNode(x);

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;

    t->next = n;
    n->prev = t;
    return head;
}

// Insert after given position
struct Node* insertAfter(struct Node *head, int pos, int x) {
    if (!head) return head;

    struct Node *t = head;
    int i = 1;

    while (t && i < pos) {
        t = t->next;
        i++;
    }

    if (!t) {
        printf("Position out of range!\n");
        return head;
    }

    struct Node *n = createNode(x);
    n->next = t->next;
    n->prev = t;

    if (t->next)
        t->next->prev = n;

    t->next = n;
    return head;
}

// Sort the DLL
struct Node* sortList(struct Node *head) {
    if (!head) return head;

    for (struct Node *i = head; i->next; i++) {
        for (struct Node *j = i->next; j; j++) {
            if (i->data > j->data) {
                int temp = i->data;
                i->data = j->data;
                j->data = temp;
            }
        }
    }
    return head;
}

// Display DLL
void display(struct Node *head) {
    while (head) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int ch, x, pos;

    while (1) {
        printf("\n1.InsertEnd  2.InsertAfterPos  3.Sort  4.Display  5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            head = insertEnd(head, x);
        }
        else if (ch == 2) {
            printf("Enter position and value: ");
            scanf("%d%d", &pos, &x);
            head = insertAfter(head, pos, x);
        }
        else if (ch == 3) head = sortList(head);
        else if (ch == 4) display(head);
        else break;
    }

    return 0;
}


// ==================================================================
// FILE: ds/12_DoublyLinkedListInsertEnd.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *prev, *next;
};

struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->prev = n->next = NULL;
    return n;
}

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = createNode(x);
    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;

    t->next = n;
    n->prev = t;
    return head;
}

// Concatenate list2 at end of list1
struct Node* concatenate(struct Node *h1, struct Node *h2) {
    if (!h1) return h2;
    if (!h2) return h1;

    struct Node *t = h1;
    while (t->next) t = t->next;

    t->next = h2;
    h2->prev = t;

    return h1;
}

// Display list
void display(struct Node *head) {
    while (head) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main() {
    struct Node *h1 = NULL, *h2 = NULL;
    int ch, x;

    while (1) {
        printf("\n1.Insert L1  2.Insert L2  3.Concatenate  4.Display L1  5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Value: "); scanf("%d", &x);
            h1 = insertEnd(h1, x);
        }
        else if (ch == 2) {
            printf("Value: "); scanf("%d", &x);
            h2 = insertEnd(h2, x);
        }
        else if (ch == 3) {
            h1 = concatenate(h1, h2);
            printf("Lists concatenated.\n");
        }
        else if (ch == 4) display(h1);
        else break;
    }

    return 0;
}


// ==================================================================
// FILE: ds/13_LinkedListRemoveDuplicates.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;
    t->next = n;

    return head;
}

// Delete duplicates in sorted LL
struct Node* removeDuplicates(struct Node *head) {
    struct Node *t = head;

    while (t && t->next) {
        if (t->data == t->next->data) {
            struct Node *temp = t->next;
            t->next = temp->next;
            free(temp);
        } else {
            t = t->next;
        }
    }
    return head;
}

// Display
void display(struct Node *head) {
    while (head) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int x;

    printf("Enter sorted list elements (-1 to stop): ");
    while (1) {
        scanf("%d", &x);
        if (x == -1) break;
        head = insertEnd(head, x);
    }

    head = removeDuplicates(head);

    printf("List after removing duplicates:\n");
    display(head);

    return 0;
}


// ==================================================================
// FILE: ds/14_LinkedListPartitionAroundX.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;
    t->next = n;

    return head;
}

// Partition list
struct Node* partition(struct Node *head, int x) {
    struct Node *lessH = NULL, *greaterH = NULL;
    struct Node *lessT = NULL, *greaterT = NULL;

    while (head) {
        if (head->data < x) {
            if (!lessH) lessH = lessT = head;
            else { lessT->next = head; lessT = head; }
        }
        else {
            if (!greaterH) greaterH = greaterT = head;
            else { greaterT->next = head; greaterT = head; }
        }
        head = head->next;
    }

    if (greaterT) greaterT->next = NULL;

    if (!lessH) return greaterH;

    lessT->next = greaterH;
    return lessH;
}

// Display
void display(struct Node *head) {
    while (head) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int x, val;

    printf("Enter list elements (-1 to stop): ");
    while (1) {
        scanf("%d", &val);
        if (val == -1) break;
        head = insertEnd(head, val);
    }

    printf("Enter partition value x: ");
    scanf("%d", &x);

    head = partition(head, x);

    printf("Partitioned List:\n");
    display(head);

    return 0;
}


// ==================================================================
// FILE: ds/15_BSTTraversal.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create new node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Insert node in BST
struct Node* insert(struct Node *root, int x) {
    if (!root) return createNode(x);

    if (x < root->data)
        root->left = insert(root->left, x);
    else
        root->right = insert(root->right, x);

    return root;
}

// Inorder
void inorder(struct Node *root) {
    if (!root) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Preorder
void preorder(struct Node *root) {
    if (!root) return;
    printf("%d ", root->data);
    preorder(root->left);
    preorder(root->right);
}

// Postorder
void postorder(struct Node *root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    struct Node *root = NULL;
    int x;

    printf("Enter elements to insert into BST (-1 to stop): ");
    while (1) {
        scanf("%d", &x);
        if (x == -1) break;
        root = insert(root, x);
    }

    printf("\nInorder Traversal: ");
    inorder(root);

    printf("\nPreorder Traversal: ");
    preorder(root);

    printf("\nPostorder Traversal: ");
    postorder(root);

    return 0;
}


// ==================================================================
// FILE: ds/16_GraphAdjencencyMatrix+BFS.c
// ==================================================================

#include <stdio.h>

#define MAX 20

int adj[MAX][MAX];
int visited[MAX];
int queue[MAX];
int front = -1, rear = -1;

// Enqueue
void enqueue(int x) {
    if (rear == MAX - 1) return;
    if (front == -1) front = 0;
    queue[++rear] = x;
}

// Dequeue
int dequeue() {
    if (front == -1 || front > rear) return -1;
    return queue[front++];
}

// BFS Traversal
void BFS(int start, int n) {
    for (int i = 0; i < n; i++)
        visited[i] = 0;

    enqueue(start);
    visited[start] = 1;

    printf("BFS Traversal: ");

    while (front <= rear) {
        int v = dequeue();
        printf("%d ", v);

        for (int i = 0; i < n; i++) {
            if (adj[v][i] == 1 && !visited[i]) {
                enqueue(i);
                visited[i] = 1;
            }
        }
    }
    printf("\n");
}

int main() {
    int n, edges, u, v, start;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            adj[i][j] = 0;

    printf("Enter edges (u v):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d%d", &u, &v);
        adj[u][v] = adj[v][u] = 1;  // undirected
    }

    printf("Enter start vertex: ");
    scanf("%d", &start);

    BFS(start, n);

    return 0;
}


// ==================================================================
// FILE: ds/17_GraphAdjencencyList+BFS.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 20

struct Node {
    int vertex;
    struct Node *next;
};

struct Node* adj[MAX];
int visited[MAX];
int queue[MAX];
int front = -1, rear = -1;

// Add edge
void addEdge(int u, int v) {
    struct Node *n = malloc(sizeof(struct Node));
    n->vertex = v;
    n->next = adj[u];
    adj[u] = n;
}

// Enqueue
void enqueue(int x) {
    if (rear == MAX - 1) return;
    if (front == -1) front = 0;
    queue[++rear] = x;
}

// Dequeue
int dequeue() {
    if (front == -1 || front > rear) return -1;
    return queue[front++];
}

// BFS Traversal
void BFS(int start, int n) {
    for (int i = 0; i < n; i++)
        visited[i] = 0;

    enqueue(start);
    visited[start] = 1;

    printf("BFS Traversal: ");

    while (front <= rear) {
        int v = dequeue();
        printf("%d ", v);

        struct Node *t = adj[v];
        while (t) {
            if (!visited[t->vertex]) {
                enqueue(t->vertex);
                visited[t->vertex] = 1;
            }
            t = t->next;
        }
    }
    printf("\n");
}

int main() {
    int n, edges, u, v, start;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < n; i++) adj[i] = NULL;

    printf("Enter edges (u v):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);  // undirected
    }

    printf("Enter start vertex: ");
    scanf("%d", &start);

    BFS(start, n);

    return 0;
}


// ==================================================================
// FILE: ds/18_GraphAdjencencyMatrix+DFS.c
// ==================================================================

#include <stdio.h>

#define MAX 20

int adj[MAX][MAX];
int visited[MAX];

// DFS recursive
void DFS(int v, int n) {
    visited[v] = 1;
    printf("%d ", v);

    for (int i = 0; i < n; i++) {
        if (adj[v][i] == 1 && !visited[i])
            DFS(i, n);
    }
}

int main() {
    int n, edges, u, v, start;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            adj[i][j] = 0;

    printf("Enter edges (u v):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d%d", &u, &v);
        adj[u][v] = adj[v][u] = 1;
    }

    printf("Enter start vertex: ");
    scanf("%d", &start);

    printf("DFS Traversal: ");
    for (int i = 0; i < n; i++) visited[i] = 0;
    DFS(start, n);

    printf("\n");
    return 0;
}


// ==================================================================
// FILE: ds/19_GraphAdjencencyList+DFS.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 20

struct Node {
    int vertex;
    struct Node *next;
};

struct Node* adj[MAX];
int visited[MAX];

// Add edge
void addEdge(int u, int v) {
    struct Node *n = malloc(sizeof(struct Node));
    n->vertex = v;
    n->next = adj[u];
    adj[u] = n;
}

// DFS
void DFS(int v) {
    visited[v] = 1;
    printf("%d ", v);

    struct Node *t = adj[v];
    while (t) {
        if (!visited[t->vertex])
            DFS(t->vertex);
        t = t->next;
    }
}

int main() {
    int n, edges, u, v, start;

    printf("Enter number of vertices: ");
    scanf("%d", &n);

    printf("Enter number of edges: ");
    scanf("%d", &edges);

    for (int i = 0; i < n; i++) adj[i] = NULL;

    printf("Enter edges (u v):\n");
    for (int i = 0; i < edges; i++) {
        scanf("%d%d", &u, &v);
        addEdge(u, v);
        addEdge(v, u);  // undirected
    }

    printf("Enter start vertex: ");
    scanf("%d", &start);

    printf("DFS Traversal: ");
    for (int i = 0; i < n; i++) visited[i] = 0;

    DFS(start);

    printf("\n");
    return 0;
}


// ==================================================================
// FILE: ds/20_HashTableLinear.c
// ==================================================================

#include <stdio.h>

#define SIZE 20

int hashTable[SIZE];

// Initialize table with -1 (empty)
void init() {
    for (int i = 0; i < SIZE; i++)
        hashTable[i] = -1;
}

// Hash function
int hash(int key) {
    return key % SIZE;
}

// Insert using linear probing
void insert(int key) {
    int idx = hash(key);

    for (int i = 0; i < SIZE; i++) {
        int newIdx = (idx + i) % SIZE;

        if (hashTable[newIdx] == -1) {
            hashTable[newIdx] = key;
            printf("Inserted %d at index %d\n", key, newIdx);
            return;
        }
    }
    printf("Hash Table FULL!\n");
}

// Search using linear probing
void search(int key) {
    int idx = hash(key);

    for (int i = 0; i < SIZE; i++) {
        int newIdx = (idx + i) % SIZE;

        if (hashTable[newIdx] == key) {
            printf("Key %d found at index %d\n", key, newIdx);
            return;
        }
        if (hashTable[newIdx] == -1) break;
    }
    printf("Key %d NOT found\n", key);
}

// Display table
void display() {
    for (int i = 0; i < SIZE; i++)
        printf("[%d] -> %d\n", i, hashTable[i]);
}

int main() {
    int ch, key;

    init();

    while (1) {
        printf("\n1.Insert  2.Search  3.Display  4.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter key: ");
            scanf("%d", &key);
            insert(key);
        }
        else if (ch == 2) {
            printf("Enter key: ");
            scanf("%d", &key);
            search(key);
        }
        else if (ch == 3) {
            display();
        }
        else break;
    }

    return 0;
}


// ==================================================================
// FILE: ds/21_HashTableQuadratic.c
// ==================================================================

#include <stdio.h>

#define SIZE 20

int hashTable[SIZE];

// Initialize table with -1 (empty)
void init() {
    for (int i = 0; i < SIZE; i++)
        hashTable[i] = -1;
}

// Hash function
int hash(int key) {
    return key % SIZE;
}

// Insert using Quadratic Probing
void insert(int key) {
    int idx = hash(key);

    for (int i = 0; i < SIZE; i++) {
        int newIdx = (idx + i*i) % SIZE;    // quadratic probe

        if (hashTable[newIdx] == -1) {
            hashTable[newIdx] = key;
            printf("Inserted %d at index %d\n", key, newIdx);
            return;
        }
    }
    printf("Hash Table FULL!\n");
}

// Search using Quadratic Probing
void search(int key) {
    int idx = hash(key);

    for (int i = 0; i < SIZE; i++) {
        int newIdx = (idx + i*i) % SIZE;

        if (hashTable[newIdx] == key) {
            printf("Key %d found at index %d\n", key, newIdx);
            return;
        }

        if (hashTable[newIdx] == -1)
            break;
    }
    printf("Key %d NOT found\n", key);
}

// Display
void display() {
    for (int i = 0; i < SIZE; i++)
        printf("[%d] -> %d\n", i, hashTable[i]);
}

int main() {
    int ch, key;

    init();

    while (1) {
        printf("\n1.Insert  2.Search  3.Display  4.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter key: ");
            scanf("%d", &key);
            insert(key);
        }
        else if (ch == 2) {
            printf("Enter key: ");
            scanf("%d", &key);
            search(key);
        }
        else if (ch == 3) display();
        else break;
    }
    return 0;
}


// ==================================================================
// FILE: ds/22_MinHeapSort.c
// ==================================================================

#include <stdio.h>

#define MAX 50

int heap[MAX];
int size = 0;

// Swap utility
void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}

// Heapify downward
void heapify(int i) {
    int smallest = i;
    int l = 2*i + 1;
    int r = 2*i + 2;

    if (l < size && heap[l] < heap[smallest])
        smallest = l;

    if (r < size && heap[r] < heap[smallest])
        smallest = r;

    if (smallest != i) {
        swap(&heap[i], &heap[smallest]);
        heapify(smallest);
    }
}

// Insert in min heap
void insert(int x) {
    heap[size] = x;
    int i = size;
    size++;

    // Fix up
    while (i != 0 && heap[(i - 1) / 2] > heap[i]) {
        swap(&heap[i], &heap[(i - 1) / 2]);
        i = (i - 1) / 2;
    }
}

// Extract min element
int extractMin() {
    if (size == 0) {
        printf("Heap empty!\n");
        return -1;
    }

    int root = heap[0];
    heap[0] = heap[size - 1];
    size--;
    heapify(0);

    return root;
}

// Heap sort (ascending)
void heapSort() {
    int tempSize = size;

    printf("Sorted Elements: ");
    while (size > 0)
        printf("%d ", extractMin());

    size = tempSize;
}

void display() {
    printf("Heap: ");
    for (int i = 0; i < size; i++)
        printf("%d ", heap[i]);
    printf("\n");
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Insert  2.ExtractMin  3.Display  4.HeapSort  5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            insert(x);
        }
        else if (ch == 2)
            printf("Min = %d\n", extractMin());
        else if (ch == 3)
            display();
        else if (ch == 4)
            heapSort();
        else break;
    }
    return 0;
}


// ==================================================================
// FILE: ds/23_AddNumbersLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;
    t->next = n;
    return head;
}

// Reverse linked list
struct Node* reverse(struct Node *head) {
    struct Node *prev = NULL, *curr = head, *next;

    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}

// Add two reversed lists
struct Node* addLists(struct Node *l1, struct Node *l2) {
    struct Node *res = NULL, *t;
    int carry = 0;

    while (l1 || l2 || carry) {
        int sum = carry;

        if (l1) { sum += l1->data; l1 = l1->next; }
        if (l2) { sum += l2->data; l2 = l2->next; }

        carry = sum / 10;

        struct Node *n = malloc(sizeof(struct Node));
        n->data = sum % 10;
        n->next = NULL;

        if (!res) res = t = n;
        else { t->next = n; t = n; }
    }
    return res;
}

// Display list
void display(struct Node *h) {
    while (h) { printf("%d ", h->data); h = h->next; }
    printf("\n");
}

int main() {
    struct Node *a = NULL, *b = NULL;
    int x;

    printf("Enter number 1 digits (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        a = insertEnd(a, x);

    printf("Enter number 2 digits (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        b = insertEnd(b, x);

    a = reverse(a);
    b = reverse(b);

    struct Node *res = addLists(a, b);
    res = reverse(res);

    printf("Result: ");
    display(res);

    return 0;
}


// ==================================================================
// FILE: ds/24_MaxHeapSort.c
// ==================================================================

#include <stdio.h>

#define MAX 50

int heap[MAX];
int size = 0;

// Swap utility
void swap(int *a, int *b) {
    int t = *a; *a = *b; *b = t;
}

// Heapify downward
void heapify(int i) {
    int largest = i;
    int l = 2*i + 1;
    int r = 2*i + 2;

    if (l < size && heap[l] > heap[largest])
        largest = l;

    if (r < size && heap[r] > heap[largest])
        largest = r;

    if (largest != i) {
        swap(&heap[i], &heap[largest]);
        heapify(largest);
    }
}

// Insert into max heap
void insert(int x) {
    heap[size] = x;
    int i = size;
    size++;

    while (i > 0 && heap[(i - 1)/2] < heap[i]) {
        swap(&heap[i], &heap[(i - 1)/2]);
        i = (i - 1) / 2;
    }
}

// Extract max
int extractMax() {
    if (size == 0) {
        printf("Heap empty!\n");
        return -1;
    }

    int root = heap[0];
    heap[0] = heap[size - 1];
    size--;
    heapify(0);

    return root;
}

// Heap sort
void heapSort() {
    int tempSize = size;

    printf("Sorted (Descending): ");
    while (size > 0)
        printf("%d ", extractMax());
    printf("\n");

    size = tempSize;
}

void display() {
    printf("Heap: ");
    for (int i = 0; i < size; i++)
        printf("%d ", heap[i]);
    printf("\n");
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Insert 2.ExtractMax 3.Display 4.HeapSort 5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            insert(x);
        }
        else if (ch == 2)
            printf("Max = %d\n", extractMax());
        else if (ch == 3) display();
        else if (ch == 4) heapSort();
        else break;
    }
    return 0;
}


// ==================================================================
// FILE: ds/25_RotateLinkedListByKPlaces.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;
    t->next = n;

    return head;
}

// Rotate list by k
struct Node* rotate(struct Node *head, int k) {
    if (!head || k == 0) return head;

    struct Node *t = head;
    int len = 1;

    while (t->next) { t = t->next; len++; }

    t->next = head;  // make circular

    k = len - (k % len);

    while (k--) t = t->next;

    head = t->next;
    t->next = NULL;

    return head;
}

// Display
void display(struct Node *h) {
    while (h) { printf("%d ", h->data); h = h->next; }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int x, k;

    printf("Enter list elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        head = insertEnd(head, x);

    printf("Enter k: ");
    scanf("%d", &k);

    head = rotate(head, k);

    printf("Rotated List: ");
    display(head);

    return 0;
}


// ==================================================================
// FILE: ds/26_SwapNodesOfLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;
    t->next = n;
    return head;
}

// Swap nodes in pairs
struct Node* swapPairs(struct Node *head) {
    if (!head || !head->next) return head;

    struct Node *curr = head->next;
    struct Node *prev = head;

    head = curr;   // new head (second node)

    while (1) {
        struct Node *next = curr->next;
        curr->next = prev;

        if (!next || !next->next) {
            prev->next = next;
            break;
        }

        prev->next = next->next;
        prev = next;
        curr = prev->next;
    }

    return head;
}

// Display list
void display(struct Node *h) {
    while (h) { printf("%d ", h->data); h = h->next; }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int x;

    printf("Enter list elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        head = insertEnd(head, x);

    head = swapPairs(head);

    printf("List after swapping pairs:\n");
    display(head);

    return 0;
}


// ==================================================================
// FILE: ds/27_SinglyLinkedListBasicOperations.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Recursive creation (insert at end)
struct Node* create(struct Node *head, int x) {
    if (!head) {
        struct Node *n = malloc(sizeof(struct Node));
        n->data = x; n->next = NULL;
        return n;
    }
    head->next = create(head->next, x);
    return head;
}

// Recursive display
void display(struct Node *head) {
    if (!head) return;
    printf("%d ", head->data);
    display(head->next);
}

// Recursive length
int length(struct Node *head) {
    if (!head) return 0;
    return 1 + length(head->next);
}

// Recursive reverse
struct Node* reverse(struct Node *head) {
    if (!head || !head->next) return head;

    struct Node *rest = reverse(head->next);
    head->next->next = head;
    head->next = NULL;

    return rest;
}

int main() {
    struct Node *head = NULL;
    int x;

    printf("Enter elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        head = create(head, x);

    printf("List: ");
    display(head);

    printf("\nLength: %d\n", length(head));

    head = reverse(head);
    printf("Reversed List: ");
    display(head);

    return 0;
}


// ==================================================================
// FILE: ds/28_OperationsOnTwoSortedLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

// Insert keeping list sorted
struct Node* insertSorted(struct Node *head, int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x; n->next = NULL;

    if (!head || x < head->data) {
        n->next = head;
        return n;
    }

    struct Node *t = head;
    while (t->next && t->next->data < x)
        t = t->next;

    n->next = t->next;
    t->next = n;
    return head;
}

// Merge two sorted lists
struct Node* merge(struct Node *a, struct Node *b) {
    if (!a) return b;
    if (!b) return a;

    if (a->data < b->data) {
        a->next = merge(a->next, b);
        return a;
    }
    else {
        b->next = merge(a, b->next);
        return b;
    }
}

// Check if lists are equal
int isEqual(struct Node *a, struct Node *b) {
    while (a && b) {
        if (a->data != b->data) return 0;
        a = a->next;
        b = b->next;
    }
    return (a == NULL && b == NULL);
}

// Copy list
struct Node* copy(struct Node *a) {
    if (!a) return NULL;

    struct Node *n = malloc(sizeof(struct Node));
    n->data = a->data;
    n->next = copy(a->next);

    return n;
}

// Display list
void display(struct Node *h) {
    while (h) { printf("%d ", h->data); h = h->next; }
    printf("\n");
}

int main() {
    struct Node *l1 = NULL, *l2 = NULL;
    int x;

    printf("Enter List 1 sorted elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        l1 = insertSorted(l1, x);

    printf("Enter List 2 sorted elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        l2 = insertSorted(l2, x);

    printf("\nMerged List: ");
    struct Node *merged = merge(l1, l2);
    display(merged);

    printf("Lists Equal? %s\n", isEqual(l1, l2) ? "YES" : "NO");

    struct Node *copyList = copy(l1);
    printf("Copy of List 1: ");
    display(copyList);

    return 0;
}


// ==================================================================
// FILE: ds/29_DoublyLinkedListBasicOperations.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *prev, *next;
};

// Create new node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x; n->prev = n->next = NULL;
    return n;
}

// Insert at end
struct Node* insertEnd(struct Node *head, int x) {
    struct Node *n = createNode(x);

    if (!head) return n;

    struct Node *t = head;
    while (t->next) t = t->next;

    t->next = n;
    n->prev = t;

    return head;
}

// Insert at given position
struct Node* insertPos(struct Node *head, int pos, int x) {
    struct Node *n = createNode(x);

    if (pos == 1) {
        n->next = head;
        if (head) head->prev = n;
        return n;
    }

    struct Node *t = head;
    for (int i = 1; t && i < pos-1; i++)
        t = t->next;

    if (!t) return head;

    n->next = t->next;
    if (t->next) t->next->prev = n;
    n->prev = t;
    t->next = n;

    return head;
}

// Delete node at pos
struct Node* deletePos(struct Node *head, int pos) {
    if (!head) return NULL;

    struct Node *t = head;

    if (pos == 1) {
        head = head->next;
        if (head) head->prev = NULL;
        free(t);
        return head;
    }

    for (int i = 1; t && i < pos; i++)
        t = t->next;

    if (!t) return head;

    if (t->prev) t->prev->next = t->next;
    if (t->next) t->next->prev = t->prev;

    free(t);
    return head;
}

// Display list
void display(struct Node *head) {
    while (head) {
        printf("%d ", head->data);
        head = head->next;
    }
    printf("\n");
}

int main() {
    struct Node *head = NULL;
    int ch, x, pos;

    while (1) {
        printf("\n1.Create 2.Display 3.Insert 4.Delete 5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            head = insertEnd(head, x);
        }
        else if (ch == 2) display(head);
        else if (ch == 3) {
            printf("Enter position & value: ");
            scanf("%d%d", &pos, &x);
            head = insertPos(head, pos, x);
        }
        else if (ch == 4) {
            printf("Enter position: ");
            scanf("%d", &pos);
            head = deletePos(head, pos);
        }
        else break;
    }

    return 0;
}


// ==================================================================
// FILE: ds/30_StackUsingLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

struct Node *top = NULL;

// Push element
void push(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = top;
    top = n;
    printf("Pushed %d\n", x);
}

// Pop element
void pop() {
    if (!top) {
        printf("Stack Underflow!\n");
        return;
    }
    struct Node *t = top;
    printf("Popped %d\n", t->data);
    top = top->next;
    free(t);
}

// Display top element
void peek() {
    if (!top) printf("Stack empty!\n");
    else printf("Top = %d\n", top->data);
}

// Display full stack
void display() {
    struct Node *t = top;
    printf("Stack: ");
    while (t) {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Push 2.Pop 3.Peek 4.Display 5.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            push(x);
        }
        else if (ch == 2) pop();
        else if (ch == 3) peek();
        else if (ch == 4) display();
        else break;
    }

    return 0;
}


// ==================================================================
// FILE: ds/31_QueueUsingLinkedList.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

struct Node *front = NULL, *rear = NULL;

// Enqueue element
void enqueue(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->next = NULL;

    if (!rear) {
        front = rear = n;
        printf("Enqueued %d\n", x);
        return;
    }
    rear->next = n;
    rear = n;
    printf("Enqueued %d\n", x);
}

// Dequeue element
void dequeue() {
    if (!front) {
        printf("Queue Underflow!\n");
        return;
    }
    struct Node *t = front;
    printf("Dequeued %d\n", t->data);
    front = front->next;
    if (!front) rear = NULL;
    free(t);
}

// Display queue
void display() {
    struct Node *t = front;
    printf("Queue: ");
    while (t) {
        printf("%d ", t->data);
        t = t->next;
    }
    printf("\n");
}

// Display front element
void frontElement() {
    if (!front) printf("Queue empty!\n");
    else printf("Front = %d\n", front->data);
}

// Display rear element
void rearElement() {
    if (!rear) printf("Queue empty!\n");
    else printf("Rear = %d\n", rear->data);
}

int main() {
    int ch, x;

    while (1) {
        printf("\n1.Enqueue 2.Dequeue 3.Display 4.Front 5.Rear 6.Exit\n");
        scanf("%d", &ch);

        if (ch == 1) {
            printf("Enter value: ");
            scanf("%d", &x);
            enqueue(x);
        }
        else if (ch == 2) dequeue();
        else if (ch == 3) display();
        else if (ch == 4) frontElement();
        else if (ch == 5) rearElement();
        else break;
    }
    return 0;
}


// ==================================================================
// FILE: ds/32_BinaryTreeInorder&Height.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create new node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Create tree recursively
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);

    if (x == -1) return NULL;

    struct Node *root = createNode(x);
    printf("Enter left child of %d\n", x);
    root->left = createTree();
    printf("Enter right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Inorder traversal
void inorder(struct Node *root) {
    if (!root) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

// Height of tree
int height(struct Node *root) {
    if (!root) return 0;
    int l = height(root->left);
    int r = height(root->right);
    return (l > r ? l : r) + 1;
}

int main() {
    struct Node *root = createTree();

    printf("\nInorder Traversal: ");
    inorder(root);

    printf("\nHeight of Tree = %d\n", height(root));

    return 0;
}


// ==================================================================
// FILE: ds/33_BinaryTreeLevelOrder.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 50

struct Node {
    int data;
    struct Node *left, *right;
};

// Create node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Build tree recursively
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);

    if (x == -1) return NULL;

    struct Node *root = createNode(x);
    printf("Enter left child of %d\n", x);
    root->left = createTree();
    printf("Enter right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Level order traversal using queue
void levelOrder(struct Node *root) {
    if (!root) return;

    struct Node *queue[MAX];
    int front = 0, rear = 0;

    queue[rear++] = root;

    printf("Level Order Traversal: ");
    while (front < rear) {
        struct Node *cur = queue[front++];
        printf("%d ", cur->data);

        if (cur->left) queue[rear++] = cur->left;
        if (cur->right) queue[rear++] = cur->right;
    }
    printf("\n");
}

int main() {
    struct Node *root = createTree();
    levelOrder(root);
    return 0;
}


// ==================================================================
// FILE: ds/34_BSTInLevelOrder.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Insert into BST
struct Node* insert(struct Node *root, int x) {
    if (!root) return createNode(x);

    if (x < root->data)
        root->left = insert(root->left, x);
    else
        root->right = insert(root->right, x);

    return root;
}

// Print descending → Right, Root, Left
void descending(struct Node *root) {
    if (!root) return;
    descending(root->right);
    printf("%d ", root->data);
    descending(root->left);
}

int main() {
    struct Node *root = NULL;
    int x;

    printf("Enter BST elements (-1 to stop): ");
    while (scanf("%d", &x) && x != -1)
        root = insert(root, x);

    printf("Descending Order Traversal: ");
    descending(root);
    printf("\n");

    return 0;
}


// ==================================================================
// FILE: ds/35_CompareTrees+Mirror.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Create tree recursively
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);

    if (x == -1) return NULL;

    struct Node *root = createNode(x);
    printf("Enter left child of %d\n", x);
    root->left = createTree();
    printf("Enter right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Check equality
int isEqual(struct Node *a, struct Node *b) {
    if (!a && !b) return 1;
    if (!a || !b) return 0;
    return (a->data == b->data &&
            isEqual(a->left, b->left) &&
            isEqual(a->right, b->right));
}

// Mirror tree by swapping left/right children
void mirror(struct Node *root) {
    if (!root) return;

    struct Node *temp = root->left;
    root->left = root->right;
    root->right = temp;

    mirror(root->left);
    mirror(root->right);
}

// Inorder display
void inorder(struct Node *root) {
    if (!root) return;
    inorder(root->left);
    printf("%d ", root->data);
    inorder(root->right);
}

int main() {
    printf("\nCreate Tree 1:\n");
    struct Node *root1 = createTree();

    printf("\nCreate Tree 2:\n");
    struct Node *root2 = createTree();

    printf("\nTrees Equal? %s\n", isEqual(root1, root2) ? "YES" : "NO");

    printf("Mirror of Tree 1 created.\n");
    mirror(root1);

    printf("Inorder of Mirrored Tree 1: ");
    inorder(root1);
    printf("\n");

    return 0;
}


// ==================================================================
// FILE: ds/36_BinaryTreeCountNodes.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create tree recursively
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);

    if (x == -1) return NULL;

    struct Node *root = malloc(sizeof(struct Node));
    root->data = x;
    root->left = root->right = NULL;

    printf("Enter left child of %d\n", x);
    root->left = createTree();
    printf("Enter right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Count total nodes
int countNodes(struct Node *root) {
    if (!root) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// Count terminal nodes (leaf)
int countLeaf(struct Node *root) {
    if (!root) return 0;
    if (!root->left && !root->right) return 1;
    return countLeaf(root->left) + countLeaf(root->right);
}

// Count non-terminal nodes
int countNonTerminal(struct Node *root) {
    if (!root) return 0;
    if (!root->left && !root->right) return 0;
    return 1 + countNonTerminal(root->left) + countNonTerminal(root->right);
}

int main() {
    struct Node *root = createTree();

    printf("\nTotal Nodes: %d\n", countNodes(root));
    printf("Terminal (Leaf) Nodes: %d\n", countLeaf(root));
    printf("Non-Terminal Nodes: %d\n", countNonTerminal(root));

    return 0;
}


// ==================================================================
// FILE: ds/37_BinaryTreeInorderNonRecursive.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 50

struct Node {
    int data;
    struct Node *left, *right;
};

struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x;
    n->left = n->right = NULL;
    return n;
}

// Recursive tree creation
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);
    if (x == -1) return NULL;

    struct Node *root = createNode(x);
    printf("Left child of %d\n", x);
    root->left = createTree();
    printf("Right child of %d\n", x);
    root->right = createTree();
    return root;
}

// Stack-based inorder traversal
void inorderNR(struct Node *root) {
    struct Node *stack[MAX];
    int top = -1;

    while (root || top != -1) {
        // Go left
        while (root) {
            stack[++top] = root;
            root = root->left;
        }

        root = stack[top--];     // Pop
        printf("%d ", root->data);
        root = root->right;
    }
}

int main() {
    struct Node *root = createTree();

    printf("\nNon-Recursive Inorder Traversal: ");
    inorderNR(root);
    printf("\n");

    return 0;
}


// ==================================================================
// FILE: ds/38_ConstructTree+PostorderTraversal.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *left, *right;
};

// Create new node
struct Node* createNode(int x) {
    struct Node *n = malloc(sizeof(struct Node));
    n->data = x; n->left = n->right = NULL;
    return n;
}

// Search index in inorder
int search(int inorder[], int start, int end, int value) {
    for (int i = start; i <= end; i++)
        if (inorder[i] == value) return i;
    return -1;
}

// Build tree from inorder & preorder
struct Node* build(int inorder[], int preorder[], int start, int end, int *preIndex) {
    if (start > end) return NULL;

    struct Node *root = createNode(preorder[*preIndex]);
    (*preIndex)++;

    if (start == end) return root;

    int inIndex = search(inorder, start, end, root->data);

    root->left = build(inorder, preorder, start, inIndex - 1, preIndex);
    root->right = build(inorder, preorder, inIndex + 1, end, preIndex);

    return root;
}

// Postorder traversal
void postorder(struct Node *root) {
    if (!root) return;
    postorder(root->left);
    postorder(root->right);
    printf("%d ", root->data);
}

int main() {
    int n;

    printf("Enter number of nodes: ");
    scanf("%d", &n);

    int inorder[n], preorder[n];

    printf("Enter Inorder Traversal: ");
    for (int i = 0; i < n; i++) scanf("%d", &inorder[i]);

    printf("Enter Preorder Traversal: ");
    for (int i = 0; i < n; i++) scanf("%d", &preorder[i]);

    int preIndex = 0;
    struct Node *root = build(inorder, preorder, 0, n - 1, &preIndex);

    printf("Postorder Traversal: ");
    postorder(root);
    printf("\n");

    return 0;
}


// ==================================================================
// FILE: ds/39_BinaryTreeNonRecursivePreorder.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 50

struct Node {
    int data;
    struct Node *left, *right;
};

// Build tree recursively
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);
    if (x == -1) return NULL;

    struct Node *root = malloc(sizeof(struct Node));
    root->data = x;
    printf("Left child of %d\n", x);
    root->left = createTree();
    printf("Right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Non-recursive preorder using stack
void preorderNR(struct Node *root) {
    if (!root) return;

    struct Node *stack[MAX];
    int top = -1;
    stack[++top] = root;

    while (top != -1) {
        struct Node *cur = stack[top--];
        printf("%d ", cur->data);

        if (cur->right) stack[++top] = cur->right;
        if (cur->left)  stack[++top] = cur->left;
    }
}

int main() {
    struct Node *root = createTree();

    printf("\nNon-Recursive Preorder: ");
    preorderNR(root);
    printf("\n");

    return 0;
}


// ==================================================================
// FILE: ds/40_BinaryTreeNonRecursivePostorder.c
// ==================================================================

#include <stdio.h>
#include <stdlib.h>

#define MAX 50

struct Node {
    int data;
    struct Node *left, *right;
};

// Create tree
struct Node* createTree() {
    int x;
    printf("Enter data (-1 for no node): ");
    scanf("%d", &x);

    if (x == -1) return NULL;

    struct Node *root = malloc(sizeof(struct Node));
    root->data = x;

    printf("Left child of %d\n", x);
    root->left = createTree();

    printf("Right child of %d\n", x);
    root->right = createTree();

    return root;
}

// Non-recursive postorder using 2 stacks
void postorderNR(struct Node *root) {
    if (!root) return;

    struct Node *stack1[MAX], *stack2[MAX];
    int top1 = -1, top2 = -1;

    stack1[++top1] = root;

    while (top1 != -1) {
        struct Node *node = stack1[top1--];
        stack2[++top2] = node;

        if (node->left) stack1[++top1] = node->left;
        if (node->right) stack1[++top1] = node->right;
    }

    while (top2 != -1)
        printf("%d ", stack2[top2--]->data);
}

int main() {
    struct Node *root = createTree();

    printf("\nNon-Recursive Postorder: ");
    postorderNR(root);
    printf("\n");

    return 0;
}
