
ALL EXPERIMENT CODES - Combined (Assembly and C)
===============================================
Author: Generated for user
Note: Assembly programs are written for MASM/TASM and DOSBox (mode 13h graphics uses VGA). 
C programs compile with: gcc filename.c -o prog

------------------------
1. ARITHMETIC OPERATIONS (8086 MASM)
------------------------
; addition_8bit.asm
.MODEL SMALL
.STACK 100h
.DATA
    VAR1 DW 0005h
    VAR2 DW 0007h
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV AX, VAR1
    MOV BX, VAR2
    ADD AX, BX        ; AX = VAR1 + VAR2
    MOV DX, AX        ; result in DX
    MOV CX, 0
    ADC CX, 0         ; CX = carry
    INT 03h
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; subtraction_8bit.asm
.MODEL SMALL
.STACK 100h
.DATA
    VAR1 DW 0001h
    VAR2 DW 0103h
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV AX, VAR2
    MOV BX, VAR1
    SUB AX, BX
    MOV DX, AX
    INT 03h
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; multiply_8bit.asm (8-bit mul -> result in AX)
.MODEL SMALL
.STACK 100h
.DATA
    VAR1 DB 03h
    VAR2 DB 05h
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV AL, VAR1
    MUL VAR2          ; AL * VAR2 -> AX
    MOV DX, AX
    INT 03h
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; divide_8bit.asm (16-bit divide example)
.MODEL SMALL
.STACK 100h
.DATA
    VAR1 DW 0006h
    VAR2 DW 0002h
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    XOR DX, DX        ; ensure DX=0 for dividend in DX:AX
    MOV AX, VAR1
    DIV VAR2          ; AX=quotient, DX=remainder
    INT 03h
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

------------------------
2. STRING OPERATIONS (8086 MASM)
------------------------
; length_string.asm - using '$' terminated string
.MODEL SMALL
.STACK 100h
.DATA
    STRING1 DB 'HelloWorld$'
.CODE
LEN_PROC PROC
    MOV AX,@DATA
    MOV DS,AX
    LEA SI, STRING1
    XOR CX, CX
LEN_LOOP:
    MOV AL, [SI]
    CMP AL, '$'
    JE LEN_DONE
    INC CX
    INC SI
    JMP LEN_LOOP
LEN_DONE:
    ; CX contains length
    INT 03h
    RET
LEN_PROC ENDP
END

; compare_strings.asm
.MODEL SMALL
.STACK 100h
.DATA
    STR1 DB 'Hello$'
    STR2 DB 'Hello$'
    RES_EQUAL DB 'STRING EQUAL$'
    RES_NOT  DB 'STRING NOT EQUAL$'
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    LEA SI, STR1
    LEA DI, STR2
CMP_LOOP2:
    MOV AL, [SI]
    MOV BL, [DI]
    CMP AL, BL
    JNE NOT_EQ
    CMP AL, '$'
    JE EQUALS
    INC SI
    INC DI
    JMP CMP_LOOP2
NOT_EQ:
    LEA DX, RES_NOT
    MOV AH,09h
    INT 21h
    JMP END_P
EQUALS:
    LEA DX, RES_EQUAL
    MOV AH,09h
    INT 21h
END_P:
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; palindrome_check.asm
.MODEL SMALL
.STACK 100h
.DATA
    STR DB 'MADAM$'
    MSG1 DB 'PALINDROME$'
    MSG2 DB 'NOT PALINDROME$'
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    LEA SI, STR
    LEA DI, STR
    XOR CX, CX
FIND_LEN2:
    MOV AL, [DI]
    CMP AL, '$'
    JE LEN_FOUND2
    INC DI
    INC CX
    JMP FIND_LEN2
LEN_FOUND2:
    DEC DI
CHECKP:
    CMP SI, DI
    JAE IS_PAL
    MOV AL, [SI]
    MOV BL, [DI]
    CMP AL, BL
    JNE NOT_PAL
    INC SI
    DEC DI
    JMP CHECKP
IS_PAL:
    LEA DX, MSG1
    MOV AH,09h
    INT 21h
    JMP END_P2
NOT_PAL:
    LEA DX, MSG2
    MOV AH,09h
    INT 21h
END_P2:
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; length without buffer - using BIOS input (INT 21h AH=0Ah) style would require buffer format.
; A simple 'without buffer' length (scan string until zero) already shown above.

------------------------
3. BLOCK OPERATIONS (MOVSB / XCHG)
------------------------
; block_copy_movsb.asm - copy src -> dest
.MODEL SMALL
.STACK 100h
.DATA
    src  DB 10h,20h,30h,40h,50h
    dest DB 5 DUP(?)
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV ES,AX
    LEA SI, src
    LEA DI, dest
    MOV CX, 5
    CLD
    REP MOVSB
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; block_swap_temp.asm - swap using temp buffer
.MODEL SMALL
.STACK 100h
.DATA
    block1 DB 11h,22h,33h,44h,55h
    block2 DB 66h,77h,88h,99h,00h
    temp   DB 5 DUP(?)
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV ES,AX
    LEA SI, block1
    LEA DI, temp
    MOV CX,5
    CLD
    REP MOVSB
    LEA SI, block2
    LEA DI, block1
    MOV CX,5
    CLD
    REP MOVSB
    LEA SI, temp
    LEA DI, block2
    MOV CX,5
    CLD
    REP MOVSB
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

; block_swap_xchg.asm - swap elements using XCHG
.MODEL SMALL
.STACK 100h
.DATA
    arr1 DB 11h,22h,33h,44h,55h
    arr2 DB 66h,77h,88h,99h,0Ah
.CODE
MAIN PROC
    MOV AX,@DATA
    MOV DS,AX
    MOV CX,5
    LEA SI, arr1
    LEA DI, arr2
SWPLOOP:
    MOV AL, [SI]
    XCHG AL, [DI]
    MOV [SI], AL
    INC SI
    INC DI
    DEC CX
    JNZ SWPLOOP
    MOV AH,4Ch
    INT 21h
MAIN ENDP
END MAIN

------------------------
4. GRAPHICS (Mode 13h, direct video memory) - Combined shapes
------------------------
.model small
.STACK 100H

.CODE
MAIN PROC

MOV AX, @DATA
MOV DS, AX

; SET GRAPHIC
MOV AH, 00
MOV AL, 13h
INT 10h

; EXTRA SEGMENT IN VIDEO MEMORY
MOV AX, 0A00H
MOV ES, AX

; INTIALISE CO-ODINATES
MOV CX, 1
MOV DX, 2
MOV BL, 2 ; GREEN COLOR

; DIAGONAL LINE
MOV AX, 30h
diagonal: call putpixal
INC CX
INC DX
DEC AX
JNZ diagonal

;horizontal line
MOV AX, 30h
horizontal: call putpixal
DEC CX
DEC AX
JNZ horizontal

;vertical line
MOV AX, 30h
vertical: call putpixal
DEC DX
DEC AX
JNZ vertical

MOV AH, 0
INT 16h

; restore text mode
MOV AH, 0
MOV AL, 03H
INT 10H

;EXIT TO DOS 
MOV AX, 4C00H
INT 21H

MAIN ENDP

putpixal proc
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI

MOV AX, DX
MOV BX, 320 
MUL BX
ADD AX, CX
MOV DI, AX


MOV ES: [DI], BL

POP DI
POP DX
POP CX
POP BX
POP AX
RET
putpixal endp
end main





------------------------
5. PASSWORD-BASED SYSTEM (masked input, 3 attempts) - assembly
------------------------
; short_password.asm
..model small
.stack 100h

.data
str         db 'Enter the password : $'
str1        db 'badak$'               ; Correct password
BUFFER      db 20,?,20 dup('$')        ; Input buffer (no backspace)
r1          db 0dh,0ah,'Password is matched.$'
r2          db 0dh,0ah,'Password is not matched.$'
r3          db 0dh,0ah,'Too many attempts. Exiting...$'
star        db '*$'
newline     db 0dh,0ah,'$'
attempts    db 3

.code
main proc
    mov ax, @data
    mov ds, ax

try_again:

    ; Print prompt
    lea dx, str
    mov ah, 09h
    int 21h

    ; DI points to buffer
    lea di, BUFFER

read_loop:
    mov ah, 00h
    int 16h               ; Read character in AL

    cmp al, 0Dh           ; Enter pressed?
    je end_input

    mov [di], al          ; Store char
    inc di

    ; Print '*'
    lea dx, star
    mov ah, 09h
    int 21h

    jmp read_loop

end_input:
    mov al, '$'
    mov [di], al          ; End password with '$'

    ; Print new line
    lea dx, newline
    mov ah, 09h
    int 21h

    ; Compare password
    lea si, str1
    lea di, BUFFER

compare_loop:
    mov al, [si]
    mov bl, [di]

    cmp al, '$'
    je check_end

    cmp al, bl
    jne not_equal

    inc si
    inc di
    jmp compare_loop

check_end:
    cmp bl, '$'
    jne not_equal
    jmp equal

equal:
    lea dx, r1
    mov ah, 09h
    int 21h
    jmp exit_program

not_equal:
    dec attempts
    lea dx, r2
    mov ah, 09h
    int 21h

    cmp attempts, 0
    je too_many

    lea dx, newline
    mov ah, 09h
    int 21h

    jmp try_again

too_many:
    lea dx, r3
    mov ah, 09h
    int 21h

exit_program:
    mov ah,4ch
    int 21h

main endp
end main

; Also included below is a simple Booth's multiplication in C for stepwise output.

; booth_mul.c (simple console C program showing steps)
#include <stdio.h>
#include <stdint.h>

int main() {
    int16_t m, r;
    int32_t a_q; // will hold A:Q combined (use 32-bit)
    int count;
    printf("Enter multiplicand (m): ");
    scanf("%hd", &m);
    printf("Enter multiplier (r): ");
    scanf("%hd", &r);
    int16_t Q = r;
    int16_t M = m;
    int8_t Q_1 = 0;
    int32_t A = 0;
    count = 16; // for 16-bit
    printf("Initial: A=%d Q=%d Q-1=%d\n", A, Q, Q_1);
    while (count--) {
        int lsb = Q & 1;
        if (lsb == 1 && Q_1 == 0) {
            A = A - M;
            printf("Subtract M: A=%d Q=%d Q-1=%d\n", A, Q, Q_1);
        } else if (lsb == 0 && Q_1 == 1) {
            A = A + M;
            printf("Add M: A=%d Q=%d Q-1=%d\n", A, Q, Q_1);
        }
        // Arithmetic right shift of A,Q,Q-1
        int newQ1 = Q & 1;
        int signA = (A < 0) ? 1 : 0;
        int combined = ((A << 16) | (Q & 0xFFFF));
        combined >>= 1;
        // extract new A and Q
        A = (combined >> 16);
        Q = (combined & 0xFFFF);
        Q_1 = newQ1;
        printf("Shift: A=%d Q=%d Q-1=%d\n", A, Q, Q_1);
    }
    int32_t product = (A << 16) | (Q & 0xFFFF);
    printf("Product = %d\n", product);
    return 0;
}

-----------
; ------------------------
#include <stdio.h>

#define MAX_CACHE 50

void printCache(int cache[], int size) {
    printf("\nCurrent Cache State (Index : Tag):\n");
    for (int i = 0; i < size; i++) {
        if (cache[i] == -1)
            printf("Index %d: [ ]\n", i);
        else
            printf("Index %d: [%d]\n", i, cache[i]);
    }
    printf("\n");
}

int main() {
    int size;
    printf("Enter cache size (number of lines): ");
    scanf("%d", &size);

    int cache[MAX_CACHE];
    for (int i = 0; i < size; i++)
        cache[i] = -1;   // initialize empty

    printf("\nEnter memory addresses (-1 to exit):\n");

    while (1) {
        int addr;
        printf("Address: ");
        scanf("%d", &addr);

        if (addr == -1) break;

        int index = addr % size;
        int tag = addr;

        if (cache[index] == tag) {
            printf("HIT → Address %d found at index %d\n", addr, index);
        } else {
            printf("MISS → Address %d placed at index %d\n", addr, index);
            cache[index] = tag;   // overwrite (direct mapping)
        }

        printCache(cache, size);
    }

    return 0;
}
2.
#include <stdio.h>

#define MAX_CACHE 50

void printCache(int cache[], int size) {
    printf("\nCurrent Cache State (Slot : Tag):\n");
    for (int i = 0; i < size; i++) {
        if (cache[i] == -1)
            printf("Slot %d: [ ]\n", i);
        else
            printf("Slot %d: [%d]\n", i, cache[i]);
    }
    printf("\n");
}

int main() {
    int size;
    printf("Enter cache size (number of blocks): ");
    scanf("%d", &size);

    int cache[MAX_CACHE];
    int fifoPtr = 0;   // For FIFO replacement

    // Initialize all cache slots to empty
    for (int i = 0; i < size; i++)
        cache[i] = -1;

    printf("\nEnter memory addresses (-1 to exit):\n");

    while (1) {
        int addr;
        printf("Address: ");
        scanf("%d", &addr);

        if (addr == -1) break;

        int tag = addr;
        int hit = 0;

        // Check HIT
        for (int i = 0; i < size; i++) {
            if (cache[i] == tag) {
                hit = 1;
                break;
            }
        }

        if (hit) {
            printf("HIT → Address %d found in cache\n", addr);
        } else {
            printf("MISS → Address %d inserted (FIFO)\n", addr);

            // FIFO replacement
            cache[fifoPtr] = tag;

            fifoPtr = (fifoPtr + 1) % size;
        }

        printCache(cache, size);
    }

    return 0;
}
3.
#include <stdio.h>

#define MAX_SETS 20
#define MAX_WAYS 20

// Function to print Cache Matrix (CM)
void printCache(int sets, int ways, int cache[MAX_SETS][MAX_WAYS]) {
    printf("\nCurrent Cache State (Set x Way):\n");
    for (int i = 0; i < sets; i++) {
        printf("Set %d: ", i);
        for (int j = 0; j < ways; j++) {
            if (cache[i][j] == -1) 
                printf("[ ] ");
            else 
                printf("[%d] ", cache[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}

int main() {
    int sets, ways;

    // Take user input for K-way associative parameters
    printf("Enter number of sets: ");
    scanf("%d", &sets);

    printf("Enter number of ways (K): ");
    scanf("%d", &ways);

    int cache[MAX_SETS][MAX_WAYS];

    // Initialize cache with -1 (empty)
    for (int i = 0; i < sets; i++)
        for (int j = 0; j < ways; j++)
            cache[i][j] = -1;

    int fifoIndex[MAX_SETS] = {0};   // Replacement pointer for each set

    printf("\nEnter memory addresses (enter -1 to stop):\n");

    while (1) {
        int addr;
        printf("Address: ");
        scanf("%d", &addr);

        if (addr == -1) break;

        // Compute SET index and TAG
        int setIndex = addr % sets;      // Mapping to set
        int tag = addr;                  // Total block number = tag (simplified)

        int hit = 0;

        // Check for HIT
        for (int i = 0; i < ways; i++) {
            if (cache[setIndex][i] == tag) {
                hit = 1;
                break;
            }
        }

        if (hit)
            printf("HIT → Address %d found in Set %d\n", addr, setIndex);
        else {
            printf("MISS → Address %d not found, placing in Set %d\n", addr, setIndex);

            // FIFO REPLACEMENT
            cache[setIndex][fifoIndex[setIndex]] = tag;
            fifoIndex[setIndex] = (fifoIndex[setIndex] + 1) % ways;
        }

        // Print updated cache matrix
        printCache(sets, ways, cache);
    }

    return 0;
}
#include <stdio.h>

int main() {
    int frames[20], pages[50];
    int nFrames, nPages;
    int i, j, hit = 0, miss = 0, pointer = 0;

    printf("Enter number of frames: ");
    scanf("%d", &nFrames);

    printf("Enter number of pages: ");
    scanf("%d", &nPages);

    printf("Enter page reference string:\n");
    for (i = 0; i < nPages; i++)
        scanf("%d", &pages[i]);

    for (i = 0; i < nFrames; i++)
        frames[i] = -1;

    printf("\nFIFO Page Replacement:\n");

    for (i = 0; i < nPages; i++) {
        int page = pages[i];
        int found = 0;

        for (j = 0; j < nFrames; j++) {
            if (frames[j] == page) {
                found = 1;
                hit++;
                break;
            }
        }

        if (!found) {
            frames[pointer] = page;
            pointer = (pointer + 1) % nFrames;
            miss++;
        }

        printf("Ref %d -> ", page);
        for (j = 0; j < nFrames; j++)
            printf("%d ", frames[j]);
        printf(found ? " (Hit)\n" : " (Miss)\n");
    }

    printf("\nTotal Hits = %d\nTotal Misses = %d\n", hit, miss);
    return 0;
}
2.
#include <stdio.h>

int main() {
    int frames[20], pages[50], recent[20];
    int nFrames, nPages;
    int i, j, k, hit = 0, miss = 0, time = 0;

    printf("Enter number of frames: ");
    scanf("%d", &nFrames);

    printf("Enter number of pages: ");
    scanf("%d", &nPages);

    printf("Enter page reference string:\n");
    for (i = 0; i < nPages; i++)
        scanf("%d", &pages[i]);

    for (i = 0; i < nFrames; i++) {
        frames[i] = -1;
        recent[i] = 0;
    }

    printf("\nLRU Page Replacement:\n");

    for (i = 0; i < nPages; i++) {
        int page = pages[i];
        int found = -1;

        for (j = 0; j < nFrames; j++) {
            if (frames[j] == page) {
                found = j;
                hit++;
                break;
            }
        }

        if (found == -1) {
            miss++;
            int lru_index = 0;

            for (j = 1; j < nFrames; j++)
                if (recent[j] < recent[lru_index])
                    lru_index = j;

            frames[lru_index] = page;
            recent[lru_index] = time;
        } else {
            recent[found] = time;
        }

        time++;

        printf("Ref %d -> ", page);
        for (k = 0; k < nFrames; k++)
            printf("%d ", frames[k]);
        printf(found != -1 ? " (Hit)\n" : " (Miss)\n");
    }

    printf("\nTotal Hits = %d\nTotal Misses = %d\n", hit, miss);
    return 0;
}
3 
#include <stdio.h>

int main() {
    int frames[20], pages[50];
    int nFrames, nPages;
    int i, j, k, hit = 0, miss = 0;

    printf("Enter number of frames: ");
    scanf("%d", &nFrames);

    printf("Enter number of pages: ");
    scanf("%d", &nPages);

    printf("Enter page reference string:\n");
    for (i = 0; i < nPages; i++)
        scanf("%d", &pages[i]);

    for (i = 0; i < nFrames; i++)
        frames[i] = -1;

    printf("\nOptimal Page Replacement:\n");

    for (i = 0; i < nPages; i++) {
        int page = pages[i];
        int found = 0;

        for (j = 0; j < nFrames; j++) {
            if (frames[j] == page) {
                hit++;
                found = 1;
                break;
            }
        }

        if (!found) {
            miss++;
            int replace = -1, farthest = -1;

            for (j = 0; j < nFrames; j++) {
                int next_use = -1;
                for (k = i + 1; k < nPages; k++) {
                    if (frames[j] == pages[k]) {
                        next_use = k;
                        break;
                    }
                }

                if (next_use == -1) { // never used again
                    replace = j;
                    break;
                }
                if (next_use > farthest) {
                    farthest = next_use;
                    replace = j;
                }
            }

            frames[replace] = page;
        }

        printf("Ref %d -> ", page);
        for (j = 0; j < nFrames; j++)
            printf("%d ", frames[j]);
        printf(found ? " (Hit)\n" : " (Miss)\n");
    }

    printf("\nTotal Hits = %d\nTotal Misses = %d\n", hit, miss);
    return 0;
}

